# .NET 9 & 10 Features Guide - LINQ, Web API, and C# Enhancements

## Overview

This guide covers the most useful .NET 9 and .NET 10 features for:
- **LINQ** - Query improvements and new operators
- **Web API / REST API** - ASP.NET Core enhancements
- **C#** - Language features and improvements

Each feature includes:
- Explanation
- Use cases
- Code examples
- Cursor AI prompts for creating POCs

---

## Table of Contents

### [.NET 9 Features](#net-9-features)
- [LINQ Enhancements](#net-9-linq-enhancements)
- [Web API Enhancements](#net-9-web-api-enhancements)
- [C# Language Features](#net-9-c-language-features)

### [.NET 10 Features](#net-10-features)
- [LINQ Enhancements](#net-10-linq-enhancements)
- [Web API Enhancements](#net-10-web-api-enhancements)
- [C# Language Features](#net-10-c-language-features)

### [POC Prompts for Cursor AI](#poc-prompts-for-cursor-ai)

---

## .NET 9 Features

### .NET 9 LINQ Enhancements

#### 1. **CountBy Method**

**What it does:** Groups elements by a key and counts occurrences in a single operation.

**Use Case:** Count items by category, status, or any grouping key.

**Example:**
```csharp
var students = new[]
{
    new { Name = "Alice", Grade = "A" },
    new { Name = "Bob", Grade = "B" },
    new { Name = "Charlie", Grade = "A" },
    new { Name = "David", Grade = "C" }
};

// Count students by grade
var gradeCounts = students.CountBy(s => s.Grade);
// Result: { ("A", 2), ("B", 1), ("C", 1) }

foreach (var (grade, count) in gradeCounts)
{
    Console.WriteLine($"Grade {grade}: {count} students");
}
```

**Benefits:**
- More efficient than `GroupBy().Count()`
- Single pass through collection
- Better performance for large datasets

---

#### 2. **AggregateBy Method**

**What it does:** Groups elements and aggregates values in a single operation.

**Use Case:** Group and aggregate data (sum, average, etc.) efficiently.

**Example:**
```csharp
var payments = new[]
{
    new { StudentId = 1, Amount = 100.00m, Status = "Completed" },
    new { StudentId = 1, Amount = 50.00m, Status = "Completed" },
    new { StudentId = 2, Amount = 200.00m, Status = "Pending" },
    new { StudentId = 2, Amount = 75.00m, Status = "Completed" }
};

// Sum payments by student
var totalByStudent = payments
    .AggregateBy(
        keySelector: p => p.StudentId,
        seed: 0m,
        (sum, payment) => sum + payment.Amount
    );

foreach (var (studentId, total) in totalByStudent)
{
    Console.WriteLine($"Student {studentId}: ${total}");
}
```

**Benefits:**
- More efficient than `GroupBy().Aggregate()`
- Supports custom aggregation logic
- Better memory usage

---

#### 3. **Index Method**

**What it does:** Adds an index to each element in a sequence.

**Use Case:** When you need both the element and its index.

**Example:**
```csharp
var activities = new[] { "Soccer", "Basketball", "Chess", "Drama" };

var indexedActivities = activities.Index();

foreach (var (index, activity) in indexedActivities)
{
    Console.WriteLine($"{index}: {activity}");
}
// Output:
// 0: Soccer
// 1: Basketball
// 2: Chess
// 3: Drama
```

**Benefits:**
- Cleaner than `Select((item, index) => ...)`
- More readable code
- Better performance

---

#### 4. **ChunkBy Method**

**What it does:** Groups consecutive elements that share the same key.

**Use Case:** Group consecutive items with the same property value.

**Example:**
```csharp
var enrollments = new[]
{
    new { StudentId = 1, Status = "Active" },
    new { StudentId = 2, Status = "Active" },
    new { StudentId = 3, Status = "Inactive" },
    new { StudentId = 4, Status = "Inactive" },
    new { StudentId = 5, Status = "Active" }
};

var chunks = enrollments.ChunkBy(e => e.Status);

foreach (var chunk in chunks)
{
    Console.WriteLine($"Status: {chunk.Key}, Count: {chunk.Count()}");
}
```

**Benefits:**
- Groups only consecutive elements
- Useful for time-series data
- More efficient than `GroupBy()` for consecutive grouping

---

### .NET 9 Web API Enhancements

#### 1. **Improved Minimal APIs with Route Groups**

**What it does:** Better organization and grouping of minimal API endpoints.

**Use Case:** Organize related endpoints without controllers.

**Example:**
```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Route group for student endpoints
var studentGroup = app.MapGroup("/api/students")
    .WithTags("Students")
    .WithOpenApi();

studentGroup.MapGet("/", () => "Get all students");
studentGroup.MapGet("/{id:int}", (int id) => $"Get student {id}");
studentGroup.MapPost("/", () => "Create student");
studentGroup.MapPut("/{id:int}", (int id) => $"Update student {id}");
studentGroup.MapDelete("/{id:int}", (int id) => $"Delete student {id}");

app.Run();
```

**Benefits:**
- Better code organization
- Shared route prefixes
- Common middleware per group
- OpenAPI/Swagger support

---

#### 2. **Enhanced OpenAPI/Swagger Support**

**What it does:** Better integration and customization of OpenAPI documentation.

**Use Case:** Generate comprehensive API documentation automatically.

**Example:**
```csharp
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "OSP API",
        Version = "v1",
        Description = "Online School Platform API"
    });
});

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
```

**Benefits:**
- Automatic API documentation
- Better developer experience
- Client code generation support

---

#### 3. **Improved Performance with Native AOT**

**What it does:** Ahead-of-time compilation for smaller, faster applications.

**Use Case:** Deploy smaller, faster microservices.

**Example:**
```xml
<PropertyGroup>
  <PublishAot>true</PublishAot>
</PropertyGroup>
```

**Benefits:**
- Smaller deployment size
- Faster startup time
- Lower memory usage
- Better for containerized deployments

---

#### 4. **Enhanced JSON Serialization**

**What it does:** Improved System.Text.Json performance and features.

**Use Case:** Faster JSON serialization/deserialization.

**Example:**
```csharp
var options = new JsonSerializerOptions
{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    WriteIndented = true,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
};

var student = new Student { Id = 1, Name = "Alice" };
var json = JsonSerializer.Serialize(student, options);
```

**Benefits:**
- Better performance
- More configuration options
- Source generation support

---

### .NET 9 C# Language Features

#### 1. **Primary Constructors for Classes**

**What it does:** Define constructor parameters directly in the class declaration.

**Use Case:** Reduce boilerplate code for simple constructors.

**Example:**
```csharp
// .NET 9: Primary constructor
public class Student(int id, string name, string email)
{
    public int Id { get; } = id;
    public string Name { get; } = name;
    public string Email { get; } = email;
    
    // Can use parameters in methods
    public string GetDisplayName() => $"{Name} ({Email})";
}

// Usage
var student = new Student(1, "Alice", "alice@school.com");
```

**Benefits:**
- Less boilerplate code
- Cleaner syntax
- Parameters available throughout class

---

#### 2. **Collection Expressions**

**What it does:** Unified syntax for creating collections.

**Use Case:** Create arrays, lists, spans with same syntax.

**Example:**
```csharp
// Works with arrays, lists, spans, etc.
int[] numbers = [1, 2, 3, 4, 5];
List<string> names = ["Alice", "Bob", "Charlie"];
Span<int> span = [10, 20, 30];

// Can spread other collections
int[] moreNumbers = [..numbers, 6, 7, 8];
```

**Benefits:**
- Consistent syntax
- More readable
- Better performance

---

#### 3. **Alias Any Type**

**What it does:** Create aliases for any type, not just named types.

**Use Case:** Simplify complex type names.

**Example:**
```csharp
using StudentId = int;
using PaymentAmount = decimal;
using StudentList = List<Student>;

// Usage
StudentId id = 123;
PaymentAmount amount = 100.50m;
StudentList students = new();
```

**Benefits:**
- Better code readability
- Type safety
- Easier refactoring

---

#### 4. **Improved Pattern Matching**

**What it does:** Enhanced pattern matching capabilities.

**Use Case:** More expressive conditional logic.

**Example:**
```csharp
public string GetStatusMessage(EnrollmentStatus status) => status switch
{
    EnrollmentStatus.Pending => "Your enrollment is pending approval",
    EnrollmentStatus.Approved => "Your enrollment has been approved",
    EnrollmentStatus.Rejected => "Your enrollment was rejected",
    EnrollmentStatus.Completed => "You have completed enrollment",
    _ => "Unknown status"
};
```

**Benefits:**
- More expressive code
- Exhaustive checking
- Better performance

---

## .NET 10 Features

> **Note:** .NET 10 is still in development. Features listed here are based on planned/announced features. Check official Microsoft documentation for the latest updates.

### .NET 10 LINQ Enhancements

#### 1. **Additional Aggregation Methods**

**What it does:** More specialized aggregation methods.

**Use Case:** Common aggregation operations.

**Example:**
```csharp
// Additional aggregation methods (planned)
var numbers = new[] { 1, 2, 3, 4, 5 };

// More specialized aggregation methods
// (Check .NET 10 release notes for specific methods)
```

---

### .NET 10 Web API Enhancements

#### 1. **Enhanced Minimal APIs**

**What it does:** Further improvements to minimal APIs.

**Use Case:** More features for API development without controllers.

**Example:**
```csharp
// Enhanced minimal API features
// (Check .NET 10 release notes for specific features)
```

---

### .NET 10 C# Language Features

#### 1. **Further Language Improvements**

**What it does:** Additional C# language enhancements.

**Use Case:** More expressive and efficient code.

**Example:**
```csharp
// Additional C# features
// (Check .NET 10 release notes for specific features)
```

---

## POC Prompts for Cursor AI

### POC 1: LINQ CountBy and AggregateBy

**Prompt for Cursor AI:**
```
Create a .NET 9 console application that demonstrates LINQ CountBy and AggregateBy methods.

Requirements:
1. Create a Student class with properties: Id, Name, Grade, SchoolId
2. Create a Payment class with properties: StudentId, Amount, Status, Date
3. Create sample data with at least 20 students and 50 payments
4. Use CountBy to count students by Grade
5. Use AggregateBy to sum payment amounts by StudentId
6. Display results in a formatted table
7. Include comments explaining each LINQ operation
8. Use primary constructors for classes
9. Use collection expressions for sample data

Create the project structure:
- Program.cs (main entry point)
- Models/Student.cs
- Models/Payment.cs
- Services/StudentService.cs (for data generation)
```

---

### POC 2: Minimal APIs with Route Groups

**Prompt for Cursor AI:**
```
Create a .NET 9 Web API application using Minimal APIs with route groups.

Requirements:
1. Create a Student API with CRUD operations using route groups
2. Create a Payment API with route groups
3. Use primary constructors for DTOs
4. Implement GET, POST, PUT, DELETE endpoints
5. Add Swagger/OpenAPI documentation
6. Use in-memory data store (List<T>)
7. Add validation using FluentValidation or Data Annotations
8. Include error handling middleware
9. Add logging for all operations
10. Use collection expressions for sample data

Project structure:
- Program.cs (API setup)
- Models/Student.cs
- Models/Payment.cs
- DTOs/StudentDto.cs
- DTOs/CreateStudentDto.cs
- DTOs/UpdateStudentDto.cs
- Services/IStudentService.cs
- Services/StudentService.cs
- Middleware/ErrorHandlingMiddleware.cs
```

---

### POC 3: Primary Constructors and Collection Expressions

**Prompt for Cursor AI:**
```
Create a .NET 9 console application demonstrating primary constructors and collection expressions.

Requirements:
1. Create classes using primary constructors:
   - Student(int id, string name, string email, int schoolId)
   - School(int id, string name, string address)
   - Enrollment(int studentId, int activityId, DateTime enrolledDate)
2. Use collection expressions to create sample data
3. Demonstrate spreading collections: [..existingCollection, newItems]
4. Create methods that use primary constructor parameters
5. Show inheritance with primary constructors
6. Display all data in formatted output
7. Include examples of:
   - Arrays with collection expressions
   - Lists with collection expressions
   - Spreading collections
   - Nested collections

Project structure:
- Program.cs
- Models/Student.cs (with primary constructor)
- Models/School.cs (with primary constructor)
- Models/Enrollment.cs (with primary constructor)
- Services/DataGenerator.cs
```

---

### POC 4: Enhanced Web API with JSON Serialization

**Prompt for Cursor AI:**
```
Create a .NET 9 Web API with enhanced JSON serialization features.

Requirements:
1. Create a Student API with minimal APIs
2. Configure System.Text.Json with:
   - Camel case naming
   - Ignore null values
   - Custom converters
   - Source generation
3. Create DTOs with different serialization scenarios
4. Add endpoints that demonstrate:
   - Serialization of complex objects
   - Custom JSON converters
   - Ignoring properties conditionally
5. Add Swagger documentation
6. Include examples of:
   - Serializing dates in custom format
   - Serializing enums as strings
   - Ignoring properties based on conditions
7. Add performance comparison (optional)

Project structure:
- Program.cs (with JSON configuration)
- Models/Student.cs
- DTOs/StudentDto.cs
- Converters/DateOnlyJsonConverter.cs
- Converters/EnumStringConverter.cs
```

---

### POC 5: LINQ Index and ChunkBy Methods

**Prompt for Cursor AI:**
```
Create a .NET 9 console application demonstrating LINQ Index and ChunkBy methods.

Requirements:
1. Create Activity class with properties: Id, Name, Status, Capacity
2. Create sample data with activities in different statuses
3. Use Index() method to add indices to activities
4. Use ChunkBy() to group consecutive activities by status
5. Display:
   - Activities with their indices
   - Chunked groups by status
6. Include real-world scenarios:
   - Processing items with their position
   - Grouping consecutive similar items
7. Add performance notes comparing to traditional approaches

Project structure:
- Program.cs
- Models/Activity.cs
- Services/ActivityService.cs
- Examples/IndexExamples.cs
- Examples/ChunkByExamples.cs
```

---

### POC 6: Complete Microservice with .NET 9 Features

**Prompt for Cursor AI:**
```
Create a complete .NET 9 microservice demonstrating all new features.

Requirements:
1. Create a Student Enrollment Service using Minimal APIs
2. Use primary constructors for all models and DTOs
3. Use collection expressions for sample data
4. Implement LINQ operations:
   - CountBy (count enrollments by status)
   - AggregateBy (sum fees by student)
   - Index (enrollment positions)
5. Use route groups for API organization
6. Configure enhanced JSON serialization
7. Add Swagger/OpenAPI documentation
8. Include:
   - Error handling middleware
   - Logging
   - Validation
   - In-memory data store
9. Use alias types for complex types
10. Demonstrate pattern matching

Project structure:
- Program.cs
- Models/Student.cs
- Models/Enrollment.cs
- Models/Fee.cs
- DTOs/ (all DTOs with primary constructors)
- Services/IEnrollmentService.cs
- Services/EnrollmentService.cs
- Middleware/ErrorHandlingMiddleware.cs
- Extensions/ServiceCollectionExtensions.cs
```

---

## Detailed Feature Explanations

### CountBy vs GroupBy().Count()

**Traditional Approach:**
```csharp
var gradeCounts = students
    .GroupBy(s => s.Grade)
    .Select(g => new { Grade = g.Key, Count = g.Count() });
```

**New Approach (.NET 9):**
```csharp
var gradeCounts = students.CountBy(s => s.Grade);
```

**Performance Benefits:**
- Single pass through collection
- No intermediate grouping object creation
- Better memory efficiency
- Faster execution for large datasets

---

### AggregateBy vs GroupBy().Aggregate()

**Traditional Approach:**
```csharp
var totals = payments
    .GroupBy(p => p.StudentId)
    .Select(g => new 
    { 
        StudentId = g.Key, 
        Total = g.Aggregate(0m, (sum, p) => sum + p.Amount) 
    });
```

**New Approach (.NET 9):**
```csharp
var totals = payments.AggregateBy(
    keySelector: p => p.StudentId,
    seed: 0m,
    (sum, payment) => sum + payment.Amount
);
```

**Performance Benefits:**
- More efficient memory usage
- Single pass operation
- Better for large datasets
- Cleaner code

---

### Primary Constructors Benefits

**Before (.NET 8):**
```csharp
public class Student
{
    public int Id { get; }
    public string Name { get; }
    public string Email { get; }
    
    public Student(int id, string name, string email)
    {
        Id = id;
        Name = name;
        Email = email;
    }
}
```

**After (.NET 9):**
```csharp
public class Student(int id, string name, string email)
{
    public int Id { get; } = id;
    public string Name { get; } = name;
    public string Email { get; } = email;
}
```

**Benefits:**
- Less boilerplate code
- Parameters available throughout class
- Can use in methods, properties, initializers
- Cleaner syntax

---

### Collection Expressions Benefits

**Before (.NET 8):**
```csharp
var numbers = new int[] { 1, 2, 3, 4, 5 };
var names = new List<string> { "Alice", "Bob" };
```

**After (.NET 9):**
```csharp
int[] numbers = [1, 2, 3, 4, 5];
List<string> names = ["Alice", "Bob"];

// Spreading
int[] moreNumbers = [..numbers, 6, 7, 8];
```

**Benefits:**
- Consistent syntax across collection types
- More readable
- Better performance
- Spreading support

---

## Migration Guide from .NET 8 to .NET 9

### Step 1: Update Project File

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <LangVersion>13.0</LangVersion>
  </PropertyGroup>
</Project>
```

### Step 2: Update NuGet Packages

```bash
dotnet add package Microsoft.AspNetCore.OpenApi
```

### Step 3: Refactor to Use New Features

1. **Replace GroupBy().Count() with CountBy()**
2. **Replace GroupBy().Aggregate() with AggregateBy()**
3. **Convert classes to use primary constructors**
4. **Update collection initializations to collection expressions**
5. **Organize Minimal APIs with route groups**

---

## Best Practices

### LINQ Best Practices

1. **Use CountBy instead of GroupBy().Count()** for better performance
2. **Use AggregateBy for grouping and aggregation** in single operation
3. **Use Index() when you need element position** instead of Select with index
4. **Use ChunkBy for consecutive grouping** instead of GroupBy

### Web API Best Practices

1. **Use route groups** to organize related endpoints
2. **Enable OpenAPI/Swagger** for better documentation
3. **Configure JSON serialization** for optimal performance
4. **Use minimal APIs** for simple endpoints
5. **Consider Native AOT** for microservices

### C# Best Practices

1. **Use primary constructors** for simple DTOs and models
2. **Use collection expressions** for consistency
3. **Use type aliases** for complex types
4. **Leverage pattern matching** for cleaner conditionals

---

## Resources

- [.NET 9 Release Notes](https://learn.microsoft.com/dotnet/core/whats-new/dotnet-9)
- [C# 13 Language Features](https://learn.microsoft.com/dotnet/csharp/whats-new/csharp-13)
- [ASP.NET Core 9 New Features](https://learn.microsoft.com/aspnet/core/release-notes/aspnetcore-9.0)
- [LINQ Improvements in .NET 9](https://learn.microsoft.com/dotnet/core/whats-new/dotnet-9#linq)

---

## Summary

### Key .NET 9 Features for Your Use Cases

**LINQ:**
- ✅ CountBy - Efficient counting by key
- ✅ AggregateBy - Efficient aggregation
- ✅ Index - Add indices to sequences
- ✅ ChunkBy - Group consecutive elements

**Web API:**
- ✅ Route groups for organization
- ✅ Enhanced OpenAPI support
- ✅ Improved JSON serialization
- ✅ Native AOT support

**C#:**
- ✅ Primary constructors
- ✅ Collection expressions
- ✅ Type aliases
- ✅ Enhanced pattern matching

Start with the POC prompts above to get hands-on experience with these features!

