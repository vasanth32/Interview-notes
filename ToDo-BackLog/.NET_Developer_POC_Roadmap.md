# .NET Developer POC Roadmap - Learn by Doing
**Timeline: 1-2 Days | Focus: Hands-on Experience with Key Job Requirements**

---

## üéØ POC Overview

**Project Name:** Task Management System with Batch Processing

**What You'll Build:**
- A REST API using .NET Core (Apollo BFF pattern)
- An Azure Function App for batch job processing
- Database integration with Entity Framework Core
- API integration between services
- Basic CI/CD pipeline setup

**Learning Objectives:**
- ‚úÖ .NET Core REST API development
- ‚úÖ Azure Function Apps for batch processing
- ‚úÖ BFF (Backend for Frontend) pattern implementation
- ‚úÖ Database operations and optimization
- ‚úÖ API integration patterns
- ‚úÖ Clean code and SOLID principles

---

## üìã Prerequisites Setup (30 minutes)

### Required Tools
- [ ] Visual Studio 2022 or VS Code with C# extension
- [ ] .NET 8 SDK (latest)
- [ ] Azure Functions Core Tools v4
- [ ] SQL Server Express (or SQL Server LocalDB) - *simulates Oracle concepts*
- [ ] Postman or Thunder Client (for API testing)
- [ ] Git
- [ ] Azure Account (free tier works)

### Install Commands
```powershell
# Install .NET 8 SDK
winget install Microsoft.DotNet.SDK.8

# Install Azure Functions Core Tools
npm install -g azure-functions-core-tools@4 --unsafe-perm true

# Verify installations
dotnet --version
func --version
```

---

## üóìÔ∏è Day 1: Core API & Database Layer (6-8 hours)

### Phase 1: Project Setup & Database (2 hours)

#### 1.1 Create Solution Structure
```powershell
# Create solution
dotnet new sln -n TaskManagementSystem

# Create projects
dotnet new webapi -n TaskManagement.API -f net8.0
dotnet new classlib -n TaskManagement.Core -f net8.0
dotnet new classlib -n TaskManagement.Infrastructure -f net8.0

# Add projects to solution
dotnet sln add TaskManagement.API/TaskManagement.API.csproj
dotnet sln add TaskManagement.Core/TaskManagement.Core.csproj
dotnet sln add TaskManagement.Infrastructure/TaskManagement.Infrastructure.csproj

# Add references
dotnet add TaskManagement.API reference TaskManagement.Core
dotnet add TaskManagement.Infrastructure reference TaskManagement.Core
dotnet add TaskManagement.API reference TaskManagement.Infrastructure
```

#### 1.2 Database Setup (Entity Framework Core)
```powershell
# Install EF Core packages
cd TaskManagement.Infrastructure
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Microsoft.EntityFrameworkCore.Tools

cd ../TaskManagement.API
dotnet add package Microsoft.EntityFrameworkCore.Design
```

**Create Domain Models** (`TaskManagement.Core/Models/`):
- `Task.cs` - Task entity
- `User.cs` - User entity
- `TaskStatus.cs` - Enum

**Create DbContext** (`TaskManagement.Infrastructure/Data/`):
- `TaskDbContext.cs` - Database context

**Key Learning Points:**
- Entity Framework Core setup (similar concepts to Oracle EF)
- Code-first migrations
- Indexing strategies (applies to Oracle too)
- Connection string configuration

#### 1.3 Run Migrations
```powershell
# Create initial migration
dotnet ef migrations add InitialCreate --project TaskManagement.Infrastructure --startup-project TaskManagement.API

# Update database
dotnet ef database update --project TaskManagement.Infrastructure --startup-project TaskManagement.API
```

---

### Phase 2: Repository Pattern & Services (2 hours)

#### 2.1 Implement Repository Pattern
**Create Interfaces** (`TaskManagement.Core/Interfaces/`):
- `ITaskRepository.cs`
- `IUnitOfWork.cs`

**Implement Repositories** (`TaskManagement.Infrastructure/Repositories/`):
- `TaskRepository.cs`
- `UnitOfWork.cs`

**Key Learning Points:**
- SOLID principles (Dependency Inversion)
- Repository pattern for data access
- Unit of Work pattern
- Async/await best practices

#### 2.2 Create Service Layer
**Create Services** (`TaskManagement.Core/Services/`):
- `ITaskService.cs` (interface)
- `TaskService.cs` (implementation)

**Key Learning Points:**
- Business logic separation
- Service layer pattern
- Dependency Injection

---

### Phase 3: REST API with BFF Pattern (3-4 hours)

#### 3.1 Implement BFF Controllers
**Create Controllers** (`TaskManagement.API/Controllers/`):
- `TasksController.cs` - Main task operations
- `UsersController.cs` - User management
- `DashboardController.cs` - Aggregated data (BFF pattern)

**BFF Pattern Implementation:**
```csharp
// DashboardController.cs - Demonstrates BFF aggregation
[ApiController]
[Route("api/[controller]")]
public class DashboardController : ControllerBase
{
    private readonly ITaskService _taskService;
    private readonly IUserService _userService;
    
    // Aggregates data from multiple services for frontend
    [HttpGet("summary")]
    public async Task<IActionResult> GetDashboardSummary()
    {
        // Orchestrate multiple service calls
        // Return optimized response for frontend
    }
}
```

**Key Learning Points:**
- REST API best practices
- BFF pattern for data aggregation
- API routing and versioning
- HTTP status codes
- Request/Response DTOs
- Input validation

#### 3.2 Add Middleware & Configuration
- Exception handling middleware
- Logging configuration
- CORS setup
- Swagger/OpenAPI documentation

#### 3.3 Test API Endpoints
Use Postman/Thunder Client to test:
- `GET /api/tasks` - List all tasks
- `GET /api/tasks/{id}` - Get task by ID
- `POST /api/tasks` - Create task
- `PUT /api/tasks/{id}` - Update task
- `DELETE /api/tasks/{id}` - Delete task
- `GET /api/dashboard/summary` - BFF aggregated data

---

## üóìÔ∏è Day 2: Azure Functions & Integration (6-8 hours)

### Phase 4: Azure Function App - Batch Job (3-4 hours)

#### 4.1 Create Azure Function Project
```powershell
# Create Azure Function project
func init TaskManagement.Functions --worker-runtime dotnet-isolated --target-framework net8.0
cd TaskManagement.Functions

# Add reference to Core project
dotnet add reference ../TaskManagement.Core/TaskManagement.Core.csproj
dotnet add reference ../TaskManagement.Infrastructure/TaskManagement.Infrastructure.csproj
```

#### 4.2 Implement Batch Job Functions
**Create Functions** (`TaskManagement.Functions/Functions/`):
- `ProcessScheduledTasks.cs` - Timer trigger (runs nightly)
- `ProcessTaskQueue.cs` - Queue trigger (event-driven)
- `CleanupOldTasks.cs` - Timer trigger (periodic cleanup)

**Example Timer Trigger:**
```csharp
public class ProcessScheduledTasks
{
    [Function("ProcessScheduledTasks")]
    public async Task Run([TimerTrigger("0 0 2 * * *")] TimerInfo timerInfo,
        FunctionContext context)
    {
        // Process scheduled tasks
        // Demonstrates migration from .NET Framework to .NET Core
    }
}
```

**Key Learning Points:**
- Azure Functions development
- Timer triggers (cron expressions)
- Queue triggers
- Error handling and retry policies
- Configuration management
- Logging in Azure Functions

#### 4.3 Local Testing
```powershell
# Run Azure Functions locally
func start
```

---

### Phase 5: API Integration (2 hours)

#### 5.1 Create Integration Service
**Create Integration Layer** (`TaskManagement.Core/Services/`):
- `IExternalApiService.cs`
- `ExternalApiService.cs` - HTTP client for external APIs

**Implement Integration Patterns:**
- REST API calls using HttpClient
- Retry policies (Polly)
- Circuit breaker pattern
- Timeout handling

**Example:**
```csharp
public class ExternalApiService : IExternalApiService
{
    private readonly HttpClient _httpClient;
    private readonly IAsyncPolicy<HttpResponseMessage> _retryPolicy;
    
    // Demonstrates API integration best practices
    public async Task<T> CallExternalApiAsync<T>(string endpoint)
    {
        // Implement retry logic, error handling
    }
}
```

**Key Learning Points:**
- HttpClient best practices
- Retry and resilience patterns
- API integration patterns (sync/async)
- Error handling for external calls

---

### Phase 6: Testing & CI/CD Setup (2 hours)

#### 6.1 Unit Testing
```powershell
# Create test project
dotnet new xunit -n TaskManagement.Tests
dotnet add TaskManagement.Tests reference TaskManagement.Core
dotnet add TaskManagement.Tests reference TaskManagement.Infrastructure
dotnet add TaskManagement.Tests package Moq
dotnet add TaskManagement.Tests package FluentAssertions
```

**Create Tests:**
- Service layer tests
- Repository tests (with in-memory database)
- Controller tests

#### 6.2 CI/CD Pipeline (Azure DevOps / GitHub Actions)
**Create Pipeline Files:**
- `.github/workflows/ci-cd.yml` (GitHub Actions) OR
- `azure-pipelines.yml` (Azure DevOps)

**Pipeline Steps:**
1. Build solution
2. Run unit tests
3. Publish API to Azure App Service
4. Deploy Azure Functions

**Key Learning Points:**
- CI/CD pipeline configuration
- Build and deployment automation
- Environment configuration

---

## üì¶ Deliverables Checklist

### Code Deliverables
- [ ] REST API with BFF pattern implementation
- [ ] Azure Function App with timer and queue triggers
- [ ] Repository pattern with Unit of Work
- [ ] Service layer with dependency injection
- [ ] API integration service with retry logic
- [ ] Unit tests (minimum 70% coverage)
- [ ] Swagger/OpenAPI documentation

### Documentation Deliverables
- [ ] README.md with setup instructions
- [ ] API documentation (Swagger)
- [ ] Architecture diagram (simple)
- [ ] Deployment guide

### Git Repository
- [ ] Initialize Git repository
- [ ] Meaningful commit messages
- [ ] `.gitignore` for .NET projects
- [ ] Branch strategy (main/develop)

---

## üéì Key Concepts to Demonstrate

### SOLID Principles
- **S**ingle Responsibility: Each class has one reason to change
- **O**pen/Closed: Extend functionality without modification
- **L**iskov Substitution: Derived classes must be substitutable
- **I**nterface Segregation: Many specific interfaces vs one general
- **D**ependency Inversion: Depend on abstractions, not concretions

### Design Patterns Used
- Repository Pattern
- Unit of Work Pattern
- Dependency Injection
- BFF (Backend for Frontend)
- Retry/Circuit Breaker (for API integration)

### Database Concepts (Oracle-applicable)
- Indexing strategies
- Query optimization
- Stored procedure concepts (can use EF Core raw SQL)
- Connection pooling
- Transaction management

---

## üöÄ Quick Start Commands

### Day 1 Start
```powershell
# Clone or create project structure
# Follow Phase 1-3 above
```

### Day 2 Start
```powershell
# Continue with Phase 4-6
# Deploy to Azure (optional but recommended)
```

### Testing Locally
```powershell
# Run API
cd TaskManagement.API
dotnet run

# Run Azure Functions
cd TaskManagement.Functions
func start

# Run Tests
dotnet test
```

---

## üìö Learning Resources (Quick Reference)

### .NET Core
- [ASP.NET Core Documentation](https://learn.microsoft.com/en-us/aspnet/core/)
- [Entity Framework Core](https://learn.microsoft.com/en-us/ef/core/)

### Azure Functions
- [Azure Functions Documentation](https://learn.microsoft.com/en-us/azure/azure-functions/)
- [Timer Triggers](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer)

### BFF Pattern
- [BFF Pattern Overview](https://samnewman.io/patterns/architectural/bff/)

### API Integration
- [HttpClient Best Practices](https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines)
- [Polly - Resilience Library](https://github.com/App-vNext/Polly)

---

## üéØ Interview Talking Points

After completing this POC, you'll be able to discuss:

1. **.NET Core vs .NET Framework**: Migration strategies, differences
2. **BFF Pattern**: Why and when to use it, implementation details
3. **Azure Functions**: Event-driven architecture, batch processing
4. **Database Optimization**: Indexing, query optimization, EF Core
5. **API Integration**: Retry patterns, circuit breakers, error handling
6. **SOLID Principles**: Real examples from your code
7. **CI/CD**: Pipeline setup, deployment strategies

---

## ‚ö° Time-Saving Tips

1. **Use Cursor AI**: Leverage AI for boilerplate code generation
2. **Scaffold Controllers**: Use Visual Studio scaffolding for quick setup
3. **Copy-Paste Patterns**: Reuse repository/service patterns
4. **Focus on Core Features**: Don't over-engineer - MVP is fine
5. **Use In-Memory DB for Tests**: Faster than real database setup

---

## üîÑ If You Have Extra Time

### Advanced Features (Optional)
- [ ] Add authentication/authorization (JWT)
- [ ] Implement caching (Redis or in-memory)
- [ ] Add health checks
- [ ] Implement API versioning
- [ ] Add request/response logging
- [ ] Performance optimization (profiling)

---

## ‚úÖ Success Criteria

You've successfully completed the POC if:
- ‚úÖ API runs locally and responds to requests
- ‚úÖ Azure Functions execute on schedule
- ‚úÖ Database operations work correctly
- ‚úÖ Unit tests pass
- ‚úÖ Code follows SOLID principles
- ‚úÖ You can explain your architecture decisions
- ‚úÖ You can demonstrate the BFF pattern
- ‚úÖ You understand the migration path from .NET Framework to .NET Core

---

## üìù Notes Section

*Use this space to document your learnings, challenges, and solutions as you build:*

---

**Good luck with your POC! Remember: The goal is to learn and demonstrate understanding, not perfection. Focus on key concepts and be ready to discuss your decisions in interviews.**

